function g(){}function A(n){return n()}function N(){return Object.create(null)}function s(n){n.forEach(A)}function M(n){return typeof n=="function"}function P(n,t){return n!=n?t==t:n!==t||n&&typeof n=="object"||typeof n=="function"}function D(n){return Object.keys(n).length===0}function G(n,t){n.appendChild(t)}function H(n,t,e){n.insertBefore(t,e||null)}function O(n){n.parentNode.removeChild(n)}function I(n,t){for(let e=0;e<n.length;e+=1)n[e]&&n[e].d(t)}function J(n){return document.createElement(n)}function S(n){return document.createTextNode(n)}function K(){return S(" ")}function Q(n,t,e,r){return n.addEventListener(t,e,r),()=>n.removeEventListener(t,e,r)}function R(n,t,e){e==null?n.removeAttribute(t):n.getAttribute(t)!==e&&n.setAttribute(t,e)}function U(n){return Array.from(n.childNodes)}function V(n,t){t=""+t,n.wholeText!==t&&(n.data=t)}let d;function p(n){d=n}function q(){if(!d)throw new Error("Function called outside component initialization");return d}function W(n){q().$$.on_mount.push(n)}function X(n){q().$$.after_update.push(n)}const i=[],b=[],h=[],C=[],Y=Promise.resolve();let _=!1;function Z(){_||(_=!0,Y.then(L))}function y(n){h.push(n)}let x=!1;const w=new Set();function L(){if(x)return;x=!0;do{for(let n=0;n<i.length;n+=1){const t=i[n];p(t),nn(t.$$)}for(p(null),i.length=0;b.length;)b.pop()();for(let n=0;n<h.length;n+=1){const t=h[n];w.has(t)||(w.add(t),t())}h.length=0}while(i.length);for(;C.length;)C.pop()();_=!1,x=!1,w.clear()}function nn(n){if(n.fragment!==null){n.update(),s(n.before_update);const t=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,t),n.after_update.forEach(y)}}const $=new Set();let c;function tn(){c={r:0,c:[],p:c}}function en(){c.r||s(c.c),c=c.p}function T(n,t){n&&n.i&&($.delete(n),n.i(t))}function on(n,t,e,r){if(n&&n.o){if($.has(n))return;$.add(n),c.c.push(()=>{$.delete(n),r&&(e&&n.d(1),r())}),n.o(t)}}function rn(n){n&&n.c()}function z(n,t,e){const{fragment:r,on_mount:f,on_destroy:l,after_update:m}=n.$$;r&&r.m(t,e),y(()=>{const a=f.map(A).filter(M);l?l.push(...a):s(a),n.$$.on_mount=[]}),m.forEach(y)}function B(n,t){const e=n.$$;e.fragment!==null&&(s(e.on_destroy),e.fragment&&e.fragment.d(t),e.on_destroy=e.fragment=null,e.ctx=[])}function un(n,t){n.$$.dirty[0]===-1&&(i.push(n),Z(),n.$$.dirty.fill(0)),n.$$.dirty[t/31|0]|=1<<t%31}function cn(n,t,e,r,f,l,m=[-1]){const a=d;p(n);const F=t.props||{},o=n.$$={fragment:null,ctx:null,props:l,update:g,not_equal:f,bound:N(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(a?a.$$.context:[]),callbacks:N(),dirty:m,skip_bound:!1};let k=!1;if(o.ctx=e?e(n,F,(u,v,...E)=>{const j=E.length?E[0]:v;return o.ctx&&f(o.ctx[u],o.ctx[u]=j)&&(!o.skip_bound&&o.bound[u]&&o.bound[u](j),k&&un(n,u)),v}):[],o.update(),k=!0,s(o.before_update),o.fragment=r?r(o.ctx):!1,t.target){if(t.hydrate){const u=U(t.target);o.fragment&&o.fragment.l(u),u.forEach(O)}else o.fragment&&o.fragment.c();t.intro&&T(n.$$.fragment),z(n,t.target,t.anchor),L()}p(a)}class an{$destroy(){B(this,1),this.$destroy=g}$on(n,t){const e=this.$$.callbacks[n]||(this.$$.callbacks[n]=[]);return e.push(t),()=>{const r=e.indexOf(t);r!==-1&&e.splice(r,1)}}$set(n){this.$$set&&!D(n)&&(this.$$.skip_bound=!0,this.$$set(n),this.$$.skip_bound=!1)}}export{an as S,X as a,G as b,R as c,b as d,en as e,rn as f,B as g,O as h,J as i,tn as j,cn as k,H as l,Q as m,z as n,W as o,V as p,K as q,s as r,P as s,S as t,T as u,on as v,I as w,g as x};
