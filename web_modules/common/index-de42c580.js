function g(){}function j(t){return t()}function A(){return Object.create(null)}function u(t){t.forEach(j)}function z(t){return typeof t=="function"}function B(t,e){return t!=t?e==e:t!==e||t&&typeof t=="object"||typeof t=="function"}function F(t){return Object.keys(t).length===0}function P(t,e){t.appendChild(e)}function G(t,e,n){t.insertBefore(e,n||null)}function M(t){t.parentNode.removeChild(t)}function H(t,e){for(let n=0;n<t.length;n+=1)t[n]&&t[n].d(e)}function I(t){return document.createElement(t)}function S(t){return document.createTextNode(t)}function J(){return S(" ")}function K(t,e,n,o){return t.addEventListener(e,n,o),()=>t.removeEventListener(e,n,o)}function Q(t,e,n){n==null?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}function R(t){return Array.from(t.childNodes)}function V(t,e){e=""+e,t.wholeText!==e&&(t.data=e)}let d;function p(t){d=t}function T(){if(!d)throw new Error("Function called outside component initialization");return d}function W(t){T().$$.on_mount.push(t)}function X(t){T().$$.after_update.push(t)}const c=[],y=[],h=[],U=[],Y=Promise.resolve();let $=!1;function Z(){$||($=!0,Y.then(C))}function b(t){h.push(t)}let x=!1;const w=new Set();function C(){if(x)return;x=!0;do{for(let t=0;t<c.length;t+=1){const e=c[t];p(e),tt(e.$$)}for(p(null),c.length=0;y.length;)y.pop()();for(let t=0;t<h.length;t+=1){const e=h[t];w.has(e)||(w.add(e),e())}h.length=0}while(c.length);for(;U.length;)U.pop()();$=!1,x=!1,w.clear()}function tt(t){if(t.fragment!==null){t.update(),u(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(b)}}const _=new Set();let i;function et(){i={r:0,c:[],p:i}}function nt(){i.r||u(i.c),i=i.p}function N(t,e){t&&t.i&&(_.delete(t),t.i(e))}function st(t,e,n,o){if(t&&t.o){if(_.has(t))return;_.add(t),i.c.push(()=>{_.delete(t),o&&(n&&t.d(1),o())}),t.o(e)}}function ot(t){t&&t.c()}function q(t,e,n){const{fragment:o,on_mount:f,on_destroy:l,after_update:m}=t.$$;o&&o.m(e,n),b(()=>{const a=f.map(j).filter(z);l?l.push(...a):u(a),t.$$.on_mount=[]}),m.forEach(b)}function D(t,e){const n=t.$$;n.fragment!==null&&(u(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function rt(t,e){t.$$.dirty[0]===-1&&(c.push(t),Z(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function it(t,e,n,o,f,l,m=[-1]){const a=d;p(t);const L=e.props||{},s=t.$$={fragment:null,ctx:null,props:l,update:g,not_equal:f,bound:A(),on_mount:[],on_destroy:[],before_update:[],after_update:[],context:new Map(a?a.$$.context:[]),callbacks:A(),dirty:m,skip_bound:!1};let v=!1;if(s.ctx=n?n(t,L,(r,E,...k)=>{const O=k.length?k[0]:E;return s.ctx&&f(s.ctx[r],s.ctx[r]=O)&&(!s.skip_bound&&s.bound[r]&&s.bound[r](O),v&&rt(t,r)),E}):[],s.update(),v=!0,u(s.before_update),s.fragment=o?o(s.ctx):!1,e.target){if(e.hydrate){const r=R(e.target);s.fragment&&s.fragment.l(r),r.forEach(M)}else s.fragment&&s.fragment.c();e.intro&&N(t.$$.fragment),q(t,e.target,e.anchor),C()}p(a)}class at{$destroy(){D(this,1),this.$destroy=g}$on(t,e){const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const o=n.indexOf(e);o!==-1&&n.splice(o,1)}}$set(t){this.$$set&&!F(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}export{at as S,X as a,P as b,Q as c,y as d,nt as e,ot as f,D as g,M as h,I as i,et as j,it as k,G as l,K as m,q as n,W as o,V as p,J as q,u as r,B as s,S as t,N as u,st as v,H as w,g as x};
